From bc51ecd0118364c7b7e3b8b878680ba96beb5771 Mon Sep 17 00:00:00 2001
From: Alberto Planas <aplanas@gmail.com>
Date: Tue, 12 May 2020 14:22:10 +0200
Subject: [PATCH] chroot: add apply_, sls and highstate for state
 execution (#187)

* chroot: use the general license

(cherry picked from commit 05afc0b783940c53a6d555b8c5b8082e3fc4295d)

* chroot: add apply_, sls and highstate for state execution

Based on the code from the SSH client wrapper, add apply_, sls and
highstate for the execution of Salt states inside a chroot environment.

(cherry picked from commit a239990efb1a74ab0045e9e9d6f31c1573462a42)

* chroot: workaround to a connection bug in salt

Some bug in Salt is preventing to use `archive.tar` inside chroot, we we
want to untar the salt_thin.tgz.

This bug is related with how much deep is the stack of __salt__ calls,
and do not clossing some connections to the master.

Tracking the AsyncZeroMQChannel connections to master:4506, we can see
that one is not closed once the actions ends, hanging the salt-call CLI.

This commit will be reverted once the root cause in found, and the bug
fixed.

(cherry picked from commit 2b833aa2f338b1f3f7107ab600c2067a10772ca4)

* chroot: do not throw exception when run_chroot fails

(cherry picked from commit 2b77f9f881957d4756cd1bb64408f49d71d79f70)
---
 salt/modules/chroot.py            | 252 ++++++++++++++++++++++++++----
 tests/unit/modules/test_chroot.py |  92 +++++++++--
 2 files changed, 298 insertions(+), 46 deletions(-)

diff --git a/salt/modules/chroot.py b/salt/modules/chroot.py
index 17b5890d8c..bc089ebf18 100644
--- a/salt/modules/chroot.py
+++ b/salt/modules/chroot.py
@@ -1,25 +1,4 @@
 # -*- coding: utf-8 -*-
-#
-# Author: Alberto Planas <aplanas@suse.com>
-#
-# Copyright 2018 SUSE LINUX GmbH, Nuernberg, Germany.
-#
-# Licensed to the Apache Software Foundation (ASF) under one
-# or more contributor license agreements.  See the NOTICE file
-# distributed with this work for additional information
-# regarding copyright ownership.  The ASF licenses this file
-# to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance
-# with the License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing,
-# software distributed under the License is distributed on an
-# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-# KIND, either express or implied.  See the License for the
-# specific language governing permissions and limitations
-# under the License.
 
 '''
 :maintainer:    Alberto Planas <aplanas@suse.com>
@@ -28,14 +7,25 @@
 :platform:      Linux
 '''
 from __future__ import absolute_import, print_function, unicode_literals
+import copy
 import logging
 import os
 import sys
 import tempfile
 
-from salt.defaults.exitcodes import EX_OK
-from salt.exceptions import CommandExecutionError
-from salt.utils.args import clean_kwargs
+
+import salt
+import salt.client.ssh.state
+import salt.client.ssh.wrapper.state
+import salt.defaults.exitcodes
+import salt.exceptions
+import salt.ext.six as six
+import salt.utils.args
+
+
+__func_alias__ = {
+    'apply_': 'apply'
+}
 
 log = logging.getLogger(__name__)
 
@@ -115,10 +105,12 @@ def call(root, function, *args, **kwargs):
     '''
 
     if not function:
-        raise CommandExecutionError('Missing function parameter')
+        raise salt.exceptions.CommandExecutionError(
+            'Missing function parameter')
 
     if not exist(root):
-        raise CommandExecutionError('Chroot environment not found')
+        raise salt.exceptions.CommandExecutionError(
+            'Chroot environment not found')
 
     # Create a temporary directory inside the chroot where we can
     # untar salt-thin
@@ -128,7 +120,14 @@ def call(root, function, *args, **kwargs):
         extra_mods=__salt__['config.option']('thin_extra_mods', ''),
         so_mods=__salt__['config.option']('thin_so_mods', '')
     )
-    stdout = __salt__['archive.tar']('xzf', thin_path, dest=thin_dest_path)
+    # Some bug in Salt is preventing us to use `archive.tar` here. A
+    # AsyncZeroMQReqChannel is not closed at the end os the salt-call,
+    # and makes the client never exit.
+    #
+    # stdout = __salt__['archive.tar']('xzf', thin_path, dest=thin_dest_path)
+    #
+    stdout = __salt__['cmd.run'](['tar', 'xzf', thin_path,
+                                  '-C', thin_dest_path])
     if stdout:
         __utils__['files.rm_rf'](thin_dest_path)
         return {'result': False, 'comment': stdout}
@@ -136,7 +135,7 @@ def call(root, function, *args, **kwargs):
     chroot_path = os.path.join(os.path.sep,
                                os.path.relpath(thin_dest_path, root))
     try:
-        safe_kwargs = clean_kwargs(**kwargs)
+        safe_kwargs = salt.utils.args.clean_kwargs(**kwargs)
         salt_argv = [
             'python{}'.format(sys.version_info[0]),
             os.path.join(chroot_path, 'salt-call'),
@@ -148,10 +147,10 @@ def call(root, function, *args, **kwargs):
             '-l', 'quiet',
             '--',
             function
-        ] + list(args) + ['{}={}'.format(k, v) for (k, v) in safe_kwargs.items()]
+        ] + list(args) + [
+            '{}={}'.format(k, v) for (k, v) in safe_kwargs.items()
+        ]
         ret = __salt__['cmd.run_chroot'](root, [str(x) for x in salt_argv])
-        if ret['retcode'] != EX_OK:
-            raise CommandExecutionError(ret['stderr'])
 
         # Process "real" result in stdout
         try:
@@ -160,10 +159,199 @@ def call(root, function, *args, **kwargs):
             if isinstance(local, dict) and 'retcode' in local:
                 __context__['retcode'] = local['retcode']
             return local.get('return', data)
-        except ValueError:
+        except (KeyError, ValueError):
             return {
                 'result': False,
                 'comment': "Can't parse container command output"
             }
     finally:
         __utils__['files.rm_rf'](thin_dest_path)
+
+
+def apply_(root, mods=None, **kwargs):
+    '''
+    Apply an state inside a chroot.
+
+    This function will call `chroot.highstate` or `chroot.sls` based
+    on the arguments passed to this function. It exists as a more
+    intuitive way of applying states.
+
+    root
+        Path to the chroot environment
+
+    For a formal description of the possible parameters accepted in
+    this function, check `state.apply_` documentation.
+
+    CLI Example:
+
+    .. code-block:: bash
+
+        salt myminion chroot.apply /chroot
+        salt myminion chroot.apply /chroot stuff
+        salt myminion chroot.apply /chroot stuff pillar='{"foo": "bar"}'
+
+    '''
+    if mods:
+        return sls(root, mods, **kwargs)
+    return highstate(root, **kwargs)
+
+
+def _create_and_execute_salt_state(root, chunks, file_refs, test, hash_type):
+    '''
+    Create the salt_stage tarball, and execute in the chroot
+    '''
+    # Create the tar containing the state pkg and relevant files.
+    salt.client.ssh.wrapper.state._cleanup_slsmod_low_data(chunks)
+    trans_tar = salt.client.ssh.state.prep_trans_tar(
+        salt.fileclient.get_file_client(__opts__), chunks, file_refs,
+        __pillar__, root)
+    trans_tar_sum = salt.utils.hashutils.get_hash(trans_tar, hash_type)
+
+    ret = None
+
+    # Create a temporary directory inside the chroot where we can move
+    # the salt_stage.tgz
+    salt_state_path = tempfile.mkdtemp(dir=root)
+    salt_state_path = os.path.join(salt_state_path, 'salt_state.tgz')
+    salt_state_path_in_chroot = salt_state_path.replace(root, '', 1)
+    try:
+        salt.utils.files.copyfile(trans_tar, salt_state_path)
+        ret = call(root, 'state.pkg', salt_state_path_in_chroot,
+                   test=test, pkg_sum=trans_tar_sum,
+                   hash_type=hash_type)
+    finally:
+        __utils__['files.rm_rf'](salt_state_path)
+
+    return ret
+
+
+def sls(root, mods, saltenv='base', test=None, exclude=None, **kwargs):
+    '''
+    Execute the states in one or more SLS files inside the chroot.
+
+    root
+        Path to the chroot environment
+
+    saltenv
+        Specify a salt fileserver environment to be used when applying
+        states
+
+    mods
+        List of states to execute
+
+    test
+        Run states in test-only (dry-run) mode
+
+    exclude
+        Exclude specific states from execution. Accepts a list of sls
+        names, a comma-separated string of sls names, or a list of
+        dictionaries containing ``sls`` or ``id`` keys. Glob-patterns
+        may be used to match multiple states.
+
+    For a formal description of the possible parameters accepted in
+    this function, check `state.sls` documentation.
+
+    CLI Example:
+
+    .. code-block:: bash
+
+        salt '*' chroot.sls /chroot stuff pillar='{"foo": "bar"}'
+    '''
+    # Get a copy of the pillar data, to avoid overwriting the current
+    # pillar, instead the one delegated
+    pillar = copy.deepcopy(__pillar__)
+    pillar.update(kwargs.get('pillar', {}))
+
+    # Clone the options data and apply some default values. May not be
+    # needed, as this module just delegate
+    opts = salt.utils.state.get_sls_opts(__opts__, **kwargs)
+    st_ = salt.client.ssh.state.SSHHighState(
+        opts, pillar, __salt__,
+        salt.fileclient.get_file_client(__opts__))
+
+    if isinstance(mods, six.string_types):
+        mods = mods.split(',')
+
+    high_data, errors = st_.render_highstate({saltenv: mods})
+    if exclude:
+        if isinstance(exclude, six.string_types):
+            exclude = exclude.split(',')
+        if '__exclude__' in high_data:
+            high_data['__exclude__'].extend(exclude)
+        else:
+            high_data['__exclude__'] = exclude
+
+    high_data, ext_errors = st_.state.reconcile_extend(high_data)
+    errors += ext_errors
+    errors += st_.state.verify_high(high_data)
+    if errors:
+        return errors
+
+    high_data, req_in_errors = st_.state.requisite_in(high_data)
+    errors += req_in_errors
+    if errors:
+        return errors
+
+    high_data = st_.state.apply_exclude(high_data)
+
+    # Compile and verify the raw chunks
+    chunks = st_.state.compile_high_data(high_data)
+    file_refs = salt.client.ssh.state.lowstate_file_refs(
+        chunks,
+        salt.client.ssh.wrapper.state._merge_extra_filerefs(
+            kwargs.get('extra_filerefs', ''),
+            opts.get('extra_filerefs', '')))
+
+    hash_type = opts['hash_type']
+    return _create_and_execute_salt_state(root, chunks, file_refs, test,
+                                          hash_type)
+
+
+def highstate(root, **kwargs):
+    '''
+    Retrieve the state data from the salt master for this minion and
+    execute it inside the chroot.
+
+    root
+        Path to the chroot environment
+
+    For a formal description of the possible parameters accepted in
+    this function, check `state.highstate` documentation.
+
+    CLI Example:
+
+    .. code-block:: bash
+
+        salt myminion chroot.highstate /chroot
+        salt myminion chroot.highstate /chroot pillar='{"foo": "bar"}'
+
+    '''
+    # Get a copy of the pillar data, to avoid overwriting the current
+    # pillar, instead the one delegated
+    pillar = copy.deepcopy(__pillar__)
+    pillar.update(kwargs.get('pillar', {}))
+
+    # Clone the options data and apply some default values. May not be
+    # needed, as this module just delegate
+    opts = salt.utils.state.get_sls_opts(__opts__, **kwargs)
+    st_ = salt.client.ssh.state.SSHHighState(
+        opts, pillar, __salt__,
+        salt.fileclient.get_file_client(__opts__))
+
+    # Compile and verify the raw chunks
+    chunks = st_.compile_low_chunks()
+    file_refs = salt.client.ssh.state.lowstate_file_refs(
+        chunks,
+        salt.client.ssh.wrapper.state._merge_extra_filerefs(
+            kwargs.get('extra_filerefs', ''),
+            opts.get('extra_filerefs', '')))
+    # Check for errors
+    for chunk in chunks:
+        if not isinstance(chunk, dict):
+            __context__['retcode'] = 1
+            return chunks
+
+    test = kwargs.pop('test', False)
+    hash_type = opts['hash_type']
+    return _create_and_execute_salt_state(root, chunks, file_refs, test,
+                                          hash_type)
diff --git a/tests/unit/modules/test_chroot.py b/tests/unit/modules/test_chroot.py
index 0e65a26606..60693fde3e 100644
--- a/tests/unit/modules/test_chroot.py
+++ b/tests/unit/modules/test_chroot.py
@@ -91,7 +91,8 @@ class ChrootTestCase(TestCase, LoaderModuleMockMixin):
         # Basic input validation
         exist.return_value = False
         self.assertRaises(CommandExecutionError, chroot.call, '/chroot', '')
-        self.assertRaises(CommandExecutionError, chroot.call, '/chroot', 'test.ping')
+        self.assertRaises(CommandExecutionError, chroot.call, '/chroot',
+                          'test.ping')
 
     @patch('salt.modules.chroot.exist')
     @patch('tempfile.mkdtemp')
@@ -107,7 +108,7 @@ class ChrootTestCase(TestCase, LoaderModuleMockMixin):
             'files.rm_rf': MagicMock(),
         }
         salt_mock = {
-            'archive.tar': MagicMock(return_value='Error'),
+            'cmd.run': MagicMock(return_value='Error'),
             'config.option': MagicMock(),
         }
         with patch.dict(chroot.__utils__, utils_mock), \
@@ -118,7 +119,7 @@ class ChrootTestCase(TestCase, LoaderModuleMockMixin):
             })
             utils_mock['thin.gen_thin'].assert_called_once()
             salt_mock['config.option'].assert_called()
-            salt_mock['archive.tar'].assert_called_once()
+            salt_mock['cmd.run'].assert_called_once()
             utils_mock['files.rm_rf'].assert_called_once()
 
     @patch('salt.modules.chroot.exist')
@@ -133,9 +134,10 @@ class ChrootTestCase(TestCase, LoaderModuleMockMixin):
         utils_mock = {
             'thin.gen_thin': MagicMock(return_value='/salt-thin.tgz'),
             'files.rm_rf': MagicMock(),
+            'json.find_json': MagicMock(return_value={'return': {}})
         }
         salt_mock = {
-            'archive.tar': MagicMock(return_value=''),
+            'cmd.run': MagicMock(return_value=''),
             'config.option': MagicMock(),
             'cmd.run_chroot': MagicMock(return_value={
                 'retcode': 1,
@@ -144,12 +146,19 @@ class ChrootTestCase(TestCase, LoaderModuleMockMixin):
         }
         with patch.dict(chroot.__utils__, utils_mock), \
                 patch.dict(chroot.__salt__, salt_mock):
-            self.assertRaises(CommandExecutionError, chroot.call, '/chroot',
-                              'test.ping')
+            self.assertEqual(chroot.call('/chroot', 'test.ping'), {
+                'result': False,
+                'comment': "Can't parse container command output"
+            })
             utils_mock['thin.gen_thin'].assert_called_once()
             salt_mock['config.option'].assert_called()
-            salt_mock['archive.tar'].assert_called_once()
-            salt_mock['cmd.run_chroot'].assert_called_once()
+            salt_mock['cmd.run'].assert_called_once()
+            salt_mock['cmd.run_chroot'].assert_called_with(
+                '/chroot',
+                ['python{}'.format(sys.version_info[0]), '/tmp01/salt-call',
+                 '--metadata', '--local',
+                 '--log-file', '/tmp01/log', '--cachedir', '/tmp01/cache',
+                 '--out', 'json', '-l', 'quiet', '--', 'test.ping'])
             utils_mock['files.rm_rf'].assert_called_once()
 
     @patch('salt.modules.chroot.exist')
@@ -167,7 +176,7 @@ class ChrootTestCase(TestCase, LoaderModuleMockMixin):
             'json.find_json': MagicMock(return_value={'return': 'result'})
         }
         salt_mock = {
-            'archive.tar': MagicMock(return_value=''),
+            'cmd.run': MagicMock(return_value=''),
             'config.option': MagicMock(),
             'cmd.run_chroot': MagicMock(return_value={
                 'retcode': 0,
@@ -179,8 +188,13 @@ class ChrootTestCase(TestCase, LoaderModuleMockMixin):
             self.assertEqual(chroot.call('/chroot', 'test.ping'), 'result')
             utils_mock['thin.gen_thin'].assert_called_once()
             salt_mock['config.option'].assert_called()
-            salt_mock['archive.tar'].assert_called_once()
-            salt_mock['cmd.run_chroot'].assert_called_once()
+            salt_mock['cmd.run'].assert_called_once()
+            salt_mock['cmd.run_chroot'].assert_called_with(
+                '/chroot',
+                ['python{}'.format(sys.version_info[0]), '/tmp01/salt-call',
+                 '--metadata', '--local',
+                 '--log-file', '/tmp01/log', '--cachedir', '/tmp01/cache',
+                 '--out', 'json', '-l', 'quiet', '--', 'test.ping'])
             utils_mock['files.rm_rf'].assert_called_once()
 
     @patch('salt.modules.chroot.exist')
@@ -198,7 +212,7 @@ class ChrootTestCase(TestCase, LoaderModuleMockMixin):
             'json.find_json': MagicMock(return_value={'return': 'result'})
         }
         salt_mock = {
-            'archive.tar': MagicMock(return_value=''),
+            'cmd.run': MagicMock(return_value=''),
             'config.option': MagicMock(),
             'cmd.run_chroot': MagicMock(return_value={
                 'retcode': 0,
@@ -211,6 +225,56 @@ class ChrootTestCase(TestCase, LoaderModuleMockMixin):
                                          user='user', key='key'), 'result')
             utils_mock['thin.gen_thin'].assert_called_once()
             salt_mock['config.option'].assert_called()
-            salt_mock['archive.tar'].assert_called_once()
-            salt_mock['cmd.run_chroot'].assert_called_once()
+            salt_mock['cmd.run'].assert_called_once()
+            salt_mock['cmd.run_chroot'].assert_called_with(
+                '/chroot',
+                ['python{}'.format(sys.version_info[0]), '/tmp01/salt-call',
+                 '--metadata', '--local',
+                 '--log-file', '/tmp01/log', '--cachedir', '/tmp01/cache',
+                 '--out', 'json', '-l', 'quiet',
+                 '--', 'ssh.set_auth_key', 'user=user', 'key=key'])
             utils_mock['files.rm_rf'].assert_called_once()
+
+    @patch('salt.modules.chroot._create_and_execute_salt_state')
+    @patch('salt.client.ssh.state.SSHHighState')
+    @patch('salt.fileclient.get_file_client')
+    @patch('salt.utils.state.get_sls_opts')
+    def test_sls(self, get_sls_opts, get_file_client, SSHHighState,
+                 _create_and_execute_salt_state):
+        '''
+        Test execution of Salt states in chroot.
+        '''
+        SSHHighState.return_value = SSHHighState
+        SSHHighState.render_highstate.return_value = (None, [])
+        SSHHighState.state.reconcile_extend.return_value = (None, [])
+        SSHHighState.state.requisite_in.return_value = (None, [])
+        SSHHighState.state.verify_high.return_value = []
+
+        _create_and_execute_salt_state.return_value = 'result'
+        opts_mock = {
+            'hash_type': 'md5',
+        }
+        get_sls_opts.return_value = opts_mock
+        with patch.dict(chroot.__opts__, opts_mock):
+            self.assertEqual(chroot.sls('/chroot', 'module'), 'result')
+            _create_and_execute_salt_state.assert_called_once()
+
+    @patch('salt.modules.chroot._create_and_execute_salt_state')
+    @patch('salt.client.ssh.state.SSHHighState')
+    @patch('salt.fileclient.get_file_client')
+    @patch('salt.utils.state.get_sls_opts')
+    def test_highstate(self, get_sls_opts, get_file_client, SSHHighState,
+                       _create_and_execute_salt_state):
+        '''
+        Test execution of Salt states in chroot.
+        '''
+        SSHHighState.return_value = SSHHighState
+
+        _create_and_execute_salt_state.return_value = 'result'
+        opts_mock = {
+            'hash_type': 'md5',
+        }
+        get_sls_opts.return_value = opts_mock
+        with patch.dict(chroot.__opts__, opts_mock):
+            self.assertEqual(chroot.highstate('/chroot'), 'result')
+            _create_and_execute_salt_state.assert_called_once()
-- 
2.26.2


